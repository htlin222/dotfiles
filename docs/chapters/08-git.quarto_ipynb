{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"版本控制的日常\"\n",
        "---\n",
        "\n",
        "# 版本控制的日常\n",
        "\n",
        "Git 是開發者的必備工具。掌握 CLI 操作比 GUI 更高效、更精確。\n",
        "\n",
        "## 基本設定\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "初次使用 Git 時，系統預設設定往往不符合個人工作習慣。例如預設編輯器可能是 vi，預設分支名稱仍是 `master`，每次 commit 都需要輸入完整的使用者資訊。這些設定問題會降低工作效率，也可能導致團隊協作時的資訊不一致。\n",
        "\n",
        "### 方法\n",
        "\n",
        "透過 `.gitconfig` 檔案集中管理 Git 的全域設定。這個檔案位於使用者家目錄下（`~/.gitconfig`），可以設定使用者資訊、編輯器偏好、預設行為、以及常用指令的別名。一次設定完成後，所有 Git repository 都會套用這些設定。\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# ~/.gitconfig\n",
        "[user]\n",
        "    name = Your Name\n",
        "    email = your@email.com\n",
        "\n",
        "[core]\n",
        "    editor = nvim\n",
        "    autocrlf = input\n",
        "\n",
        "[init]\n",
        "    defaultBranch = main\n",
        "\n",
        "[pull]\n",
        "    rebase = true\n",
        "\n",
        "[alias]\n",
        "    st = status\n",
        "    co = checkout\n",
        "    br = branch\n",
        "    ci = commit\n",
        "    lg = log --oneline --graph --all\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "- **autocrlf = input**：確保在 macOS/Linux 環境下，檢入時將 CRLF 轉為 LF，避免跨平台協作的換行符號問題\n",
        "- **pull.rebase = true**：預設使用 rebase 而非 merge，保持更乾淨的 commit history\n",
        "- **別名設定**：`lg` 是特別實用的別名，可視覺化顯示分支結構\n",
        "- 進一步學習：可探索 `git config --global` 指令動態修改設定，或研究條件式設定（針對不同專案使用不同設定）\n",
        "\n",
        "## 日常工作流\n",
        "\n",
        "### 基本操作\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "在日常開發中，我們需要追蹤檔案變更、選擇性提交部分修改、撰寫清晰的 commit 訊息，並同步到遠端 repository。若不熟悉這些基本操作，容易造成 commit 歷史混亂、誤提交不該進版本控制的檔案，或者無法有效地與團隊協作。\n",
        "\n",
        "#### 方法\n",
        "\n",
        "Git 的基本工作流程分為四個階段：\n",
        "1. **查看狀態**（`git status`）：確認哪些檔案被修改、新增或刪除\n",
        "2. **暫存變更**（`git add`）：選擇要提交的變更加入暫存區\n",
        "3. **提交變更**（`git commit`）：將暫存區的變更建立成一個 commit\n",
        "4. **推送變更**（`git push`）：將本地 commits 同步到遠端\n",
        "\n",
        "使用 `git add -p` 可以互動式地選擇要暫存的程式碼片段，實現更精細的版本控制。\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 查看狀態\n",
        "git status\n",
        "\n",
        "# 加入暫存區\n",
        "git add .\n",
        "git add -p  # 互動式選擇\n",
        "\n",
        "# 提交\n",
        "git commit -m \"feat: add new feature\"\n",
        "\n",
        "# 推送\n",
        "git push\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "- **git add -p** (patch mode)：適合當你在同一個檔案中做了多個不相關的修改，想要分別提交時使用\n",
        "- **Conventional Commits**：`feat:`、`fix:`、`docs:` 等前綴是業界標準，有助於自動產生 CHANGELOG\n",
        "- **git add .** vs **git add -A**：前者只加入當前目錄下的變更，後者加入整個 repository 的變更\n",
        "- 進一步學習：`git commit --amend` 修改最近一次 commit、`git reset` 取消暫存、`git stash` 暫存未提交的變更\n",
        "\n",
        "### 分支管理\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "在開發新功能或修復 bug 時，直接在主分支上工作會造成以下問題：\n",
        "- 未完成的功能會影響主分支的穩定性\n",
        "- 多人協作時容易產生衝突\n",
        "- 難以同時進行多個獨立的開發任務\n",
        "- 無法輕易捨棄實驗性的修改\n",
        "\n",
        "#### 方法\n",
        "\n",
        "Git 的分支機制提供了輕量級的解決方案：\n",
        "1. **建立並切換分支**（`git checkout -b`）：建立一個獨立的開發線\n",
        "2. **合併分支**（`git merge`）：將完成的功能整合回主分支\n",
        "3. **刪除分支**（`git branch -d`）：清理已合併的分支\n",
        "\n",
        "這種工作流程確保主分支始終保持可部署狀態，同時允許並行開發多個功能。\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 建立並切換分支\n",
        "git checkout -b feature/new-feature\n",
        "\n",
        "# 合併分支\n",
        "git checkout main\n",
        "git merge feature/new-feature\n",
        "\n",
        "# 刪除分支\n",
        "git branch -d feature/new-feature\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "- **分支命名慣例**：`feature/`、`bugfix/`、`hotfix/` 等前綴有助於組織分支\n",
        "- **git switch**：Git 2.23+ 推薦使用 `git switch -c feature/new-feature` 取代 `git checkout -b`\n",
        "- **git branch -D**：強制刪除未合併的分支（謹慎使用）\n",
        "- **衝突處理**：merge 時若有衝突，需手動編輯衝突檔案後再 commit\n",
        "- 進一步學習：`git rebase` 用於整理 commit history、`git cherry-pick` 挑選特定 commit\n",
        "\n",
        "## AI 輔助提交訊息\n",
        "\n",
        "### aicommits 工具\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "撰寫清晰且符合規範的 commit message 是一項耗時的工作。開發者常面臨以下困擾：\n",
        "- 不知道如何用簡潔的語言描述複雜的變更\n",
        "- 忘記使用 Conventional Commits 格式（feat:, fix: 等）\n",
        "- 多個檔案的變更難以用一句話總結\n",
        "- 中英文描述能力參差不齊\n",
        "\n",
        "#### 方法\n",
        "\n",
        "`aicommits` 是基於 AI 的工具，能自動分析 staged changes 並生成符合 Conventional Commits 規範的訊息。它會讀取 `git diff --staged` 的內容，理解程式碼變更的語意，然後產生適當的 commit message。\n",
        "\n",
        "工作流程：\n",
        "1. 暫存變更（`git add`）\n",
        "2. 執行 `aicommits`\n",
        "3. AI 分析變更並建議 commit message\n",
        "4. 確認或修改後提交\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 安裝\n",
        "npm install -g aicommits\n",
        "\n",
        "# 使用\n",
        "git add .\n",
        "aicommits\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "- **API Key 設定**：首次使用需設定 OpenAI API key：`aicommits config set OPENAI_KEY=<your-key>`\n",
        "- **客製化**：可設定 `--type conventional` 強制使用 Conventional Commits 格式\n",
        "- **多語言支援**：可設定 `--locale zh-TW` 產生繁體中文訊息\n",
        "- **成本考量**：使用 OpenAI API 會產生費用，但每次呼叫成本極低（< $0.01）\n",
        "- 替代方案：GitHub Copilot、其他本地 AI 模型\n",
        "\n",
        "### 一鍵提交函數\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "即使使用 aicommits，完整的提交流程仍需執行三個指令（add、commit、push）。對於頻繁的小型提交，這種重複操作降低了工作效率。\n",
        "\n",
        "#### 方法\n",
        "\n",
        "將整個提交流程封裝成一個 shell 函數 `zgit()`，自動化執行以下步驟：\n",
        "1. 暫存所有變更（`git add -A`）\n",
        "2. 使用 AI 生成並提交（`aicommits --type conventional`）\n",
        "3. 推送到遠端（`git push`）\n",
        "\n",
        "這個函數特別適合用於個人專案或快速原型開發。\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "function zgit() {\n",
        "  git add -A\n",
        "  aicommits --type conventional\n",
        "  git push\n",
        "}\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "- **使用時機**：適合個人專案、快速迭代；團隊專案建議保留 code review 流程\n",
        "- **安全考量**：`git add -A` 會暫存所有變更，使用前應確認沒有敏感資訊（如 API keys）\n",
        "- **進階版本**：可加入分支檢查，避免在主分支上直接 push\n",
        "- **變體實作**：可加入 `git status` 確認、或整合 pre-commit hooks\n",
        "- 進一步學習：研究 Git hooks（pre-commit、commit-msg）實現更嚴謹的流程控制\n",
        "\n",
        "## lazygit：TUI Git 客戶端\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "純指令列操作 Git 雖然精確，但在處理複雜情境時會遇到以下挑戰：\n",
        "- 難以視覺化分支結構和 commit 關係\n",
        "- 互動式 rebase 需要記憶大量指令\n",
        "- 解決 merge conflicts 時需要在編輯器和終端機間切換\n",
        "- 檢視 diff、log、stash 等資訊時缺乏直覺的導覽方式\n",
        "\n",
        "傳統的 GUI Git 客戶端（如 GitKraken、SourceTree）雖然解決了視覺化問題，但需要離開終端環境，打斷工作流程。\n",
        "\n",
        "### 方法\n",
        "\n",
        "`lazygit` 是一個 Terminal User Interface (TUI) Git 客戶端，在終端機內提供類似 GUI 的互動體驗。它將 Git 的各種功能整合到單一介面中，透過鍵盤快捷鍵和視覺化面板提供高效的操作體驗。\n",
        "\n",
        "核心特色：\n",
        "- **視覺化分支圖**：圖形化顯示 commit history 和分支關係\n",
        "- **互動式 rebase**：透過簡單的鍵盤操作重新排序、編輯、壓縮 commits\n",
        "- **衝突解決**：內建三方合併視圖，快速處理 merge conflicts\n",
        "- **滑鼠支援**：可用滑鼠點擊操作（但鍵盤更高效）\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "brew install lazygit\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**常用快捷鍵**：\n",
        "- `space`：stage/unstage 檔案\n",
        "- `c`：commit\n",
        "- `P`：push\n",
        "- `p`：pull\n",
        "- `r`：rebase\n",
        "- `m`：merge\n",
        "- `e`：edit commit message\n",
        "- `s`：squash commit\n",
        "\n",
        "**使用場景**：\n",
        "- **Rebase 工作流**：視覺化地整理 commit history，比 `git rebase -i` 直覺\n",
        "- **Cherry-pick**：輕鬆選擇特定 commits 應用到當前分支\n",
        "- **Stash 管理**：視覺化管理多個 stash entries\n",
        "- **Branch 切換**：快速瀏覽和切換分支\n",
        "\n",
        "**注意事項**：\n",
        "- 初次使用建議閱讀內建的 keybindings 說明（按 `?`）\n",
        "- 複雜操作仍可能需要回到指令列\n",
        "- 可透過 `~/.config/lazygit/config.yml` 客製化設定\n",
        "\n",
        "**進一步學習**：探索 `tig`（另一個 TUI Git 工具，專注於瀏覽 history）、`gitui`（Rust 實作的 lazygit 替代品）\n",
        "\n",
        "## forgit：fzf 整合\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "Git 的原生指令雖然功能強大，但在以下場景缺乏互動性：\n",
        "- `git log` 輸出冗長，難以快速定位特定 commit\n",
        "- `git diff` 無法快速預覽多個檔案的變更\n",
        "- `git add` 選擇檔案時需要精確輸入路徑\n",
        "- `git checkout` 切換分支或 commit 時需要記住名稱或 hash\n",
        "\n",
        "這些操作通常需要多次嘗試或搭配其他指令（如 `grep`）才能達成目標，降低了工作效率。\n",
        "\n",
        "### 方法\n",
        "\n",
        "`forgit` 是基於 `fzf` 的 Git 指令增強工具，為常用的 Git 操作加入模糊搜尋和即時預覽功能。它將 Git 指令的輸出導向 fzf，提供互動式的選擇介面。\n",
        "\n",
        "核心概念：\n",
        "- **模糊搜尋**：輸入關鍵字快速過濾 commits、檔案、分支\n",
        "- **即時預覽**：選擇項目時即時顯示詳細內容（diff、log、檔案內容）\n",
        "- **多選支援**：可同時選擇多個項目（如 staging 多個檔案）\n",
        "- **別名整合**：提供簡短的別名（`ga`、`glo`、`gd`）取代原生指令\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 互動式 git add\n",
        "ga\n",
        "\n",
        "# 互動式 git log\n",
        "glo\n",
        "\n",
        "# 互動式 git diff\n",
        "gd\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**完整功能列表**：\n",
        "- `ga`：互動式 `git add`，可預覽檔案變更\n",
        "- `glo`：互動式 `git log`，可搜尋 commit 訊息\n",
        "- `gd`：互動式 `git diff`，可預覽每個檔案的差異\n",
        "- `gcf`：互動式 `git checkout <file>`，還原檔案\n",
        "- `gss`：互動式 `git stash show`\n",
        "- `gclean`：互動式 `git clean`，安全刪除未追蹤檔案\n",
        "\n",
        "**安裝方式**：\n",
        "```bash\n",
        "# 透過 Oh My Zsh\n",
        "git clone https://github.com/wfxr/forgit.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/forgit\n",
        "\n",
        "# 或直接 source\n",
        "# 在 .zshrc 加入：\n",
        "source /path/to/forgit/forgit.plugin.zsh\n",
        "```\n",
        "\n",
        "**使用技巧**：\n",
        "- 在 fzf 介面中按 `Ctrl-R` 可切換預覽視窗\n",
        "- 使用 `Tab` 或 `Shift-Tab` 多選項目\n",
        "- 輸入 `/` 進入搜尋模式\n",
        "\n",
        "**注意事項**：\n",
        "- 需先安裝 `fzf`（`brew install fzf`）\n",
        "- 別名可能與現有的 Git aliases 衝突，可透過環境變數客製化\n",
        "- 大型 repository 可能需要調整 fzf 的效能設定\n",
        "\n",
        "**進一步學習**：研究 `git-fuzzy`（另一個 fzf + Git 整合工具）、客製化 fzf 預覽指令\n",
        "\n",
        "## GitHub CLI\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "使用 GitHub 網頁介面管理 Pull Requests 和 CI/CD workflows 時，會遇到以下痛點：\n",
        "- 需要離開終端機切換到瀏覽器\n",
        "- 建立 PR 需要填寫多個表單欄位\n",
        "- 查看 CI 失敗原因需要點擊多個頁面\n",
        "- 無法快速批次操作多個 PRs 或 issues\n",
        "- 工作流程被打斷，降低專注度\n",
        "\n",
        "這些操作雖然可行，但頻繁的上下文切換會顯著降低生產力。\n",
        "\n",
        "### 方法\n",
        "\n",
        "GitHub CLI (`gh`) 是 GitHub 官方提供的命令列工具，將 GitHub 的主要功能帶到終端機中。它透過 GitHub API 提供與網頁介面幾乎相同的功能，但以指令列介面呈現。\n",
        "\n",
        "核心功能：\n",
        "- **認證管理**（`gh auth`）：一次登入，全域使用\n",
        "- **PR 管理**（`gh pr`）：建立、查看、合併、審查 Pull Requests\n",
        "- **Issue 管理**（`gh issue`）：建立、查看、關閉 issues\n",
        "- **Actions 整合**（`gh run`）：查看 CI/CD workflow 執行結果\n",
        "- **Repository 操作**（`gh repo`）：clone、fork、create repositories\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 安裝\n",
        "brew install gh\n",
        "\n",
        "# 登入\n",
        "gh auth login\n",
        "\n",
        "# 建立 PR\n",
        "gh pr create\n",
        "\n",
        "# 查看 PR\n",
        "gh pr list\n",
        "gh pr view 123\n",
        "\n",
        "# 查看失敗的 CI\n",
        "gh run view --log-failed\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**常用指令詳解**：\n",
        "\n",
        "**PR 工作流**：\n",
        "```bash\n",
        "gh pr create --title \"feat: new feature\" --body \"Description\"\n",
        "gh pr create --web  # 在瀏覽器中開啟\n",
        "gh pr checkout 123  # 切換到 PR 的分支\n",
        "gh pr merge 123 --squash  # 合併並壓縮 commits\n",
        "gh pr review 123 --approve  # 審查並批准\n",
        "```\n",
        "\n",
        "**CI/CD 監控**：\n",
        "```bash\n",
        "gh run list --limit 10  # 列出最近 10 次執行\n",
        "gh run watch  # 即時監控當前 workflow\n",
        "gh run rerun 123  # 重新執行失敗的 workflow\n",
        "```\n",
        "\n",
        "**進階應用**：\n",
        "```bash\n",
        "gh pr list --state all --json number,title,author  # JSON 輸出，可串接 jq\n",
        "gh api repos/:owner/:repo/pulls  # 直接呼叫 GitHub API\n",
        "gh extension install github/gh-copilot  # 安裝擴充功能\n",
        "```\n",
        "\n",
        "**優勢**：\n",
        "- **整合式工作流**：commit → push → create PR 一氣呵成\n",
        "- **腳本友善**：輸出可解析，適合自動化\n",
        "- **離線工作**：快取資料，減少 API 呼叫\n",
        "\n",
        "**注意事項**：\n",
        "- 首次使用需執行 `gh auth login` 授權\n",
        "- API rate limit：每小時 5000 次（已認證），60 次（未認證）\n",
        "- 某些功能仍需使用網頁介面（如複雜的 PR review）\n",
        "\n",
        "**進一步學習**：研究 `gh extensions`（擴充 gh 功能）、整合 `gh` 與 shell 函數實現自動化工作流\n",
        "\n",
        "## 實用別名\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "使用 `gh` 指令管理 GitHub Actions 時，經常需要執行以下重複性操作：\n",
        "- 查看最近失敗的 CI run 並檢視錯誤訊息\n",
        "- 監控正在執行的 workflow 狀態\n",
        "- 列出所有失敗的 runs 以便批次處理\n",
        "\n",
        "這些指令往往很長（如 `gh run view --log-failed`），且需要記憶多個參數。頻繁輸入這些指令不僅耗時，也容易出錯。\n",
        "\n",
        "### 方法\n",
        "\n",
        "透過 shell aliases 將常用的長指令封裝成簡短、易記的別名。這種做法利用了 shell 的別名機制，讓使用者可以用簡短的關鍵字觸發完整的指令序列。\n",
        "\n",
        "設計原則：\n",
        "- **語意化命名**：`gha-last-fail` 清楚表達「GitHub Actions 最近失敗」的概念\n",
        "- **一致性前綴**：所有 GitHub Actions 相關別名都用 `gha-` 開頭，方便記憶和自動補全\n",
        "- **參數優化**：預設加入最常用的參數（如 `--compact`、`--exit-status`）\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 查看最近失敗的 run\n",
        "alias gha-last-fail='gh run view --log-failed'\n",
        "\n",
        "# 追蹤執行狀況\n",
        "alias gha-watch='gh run watch --compact --exit-status'\n",
        "\n",
        "# 查看失敗列表\n",
        "alias gha-failed-list='gh run list --status failure'\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**使用場景說明**：\n",
        "\n",
        "**gha-last-fail**：\n",
        "- 在 push 後發現 CI 失敗時，快速查看錯誤訊息\n",
        "- 不需要先用 `gh run list` 找出 run ID\n",
        "- 自動顯示失敗的 job 和錯誤日誌\n",
        "\n",
        "**gha-watch**：\n",
        "- 在 push 後即時監控 CI 執行進度\n",
        "- `--compact`：精簡輸出，減少終端機捲動\n",
        "- `--exit-status`：workflow 完成後自動退出，並返回正確的 exit code\n",
        "\n",
        "**gha-failed-list**：\n",
        "- 一次檢視所有失敗的 runs\n",
        "- 可搭配 `jq` 進一步處理：`gha-failed-list --json number,conclusion | jq`\n",
        "\n",
        "**擴充建議**：\n",
        "```bash\n",
        "# 快速重試最近失敗的 run\n",
        "alias gha-retry='gh run rerun $(gh run list --status failure --limit 1 --json databaseId -q \".[0].databaseId\")'\n",
        "\n",
        "# 查看特定 workflow 的狀態\n",
        "alias gha-status='gh run list --workflow'\n",
        "\n",
        "# 取消正在執行的 runs\n",
        "alias gha-cancel-all='gh run list --status in_progress --json databaseId -q \".[].databaseId\" | xargs -I {} gh run cancel {}'\n",
        "```\n",
        "\n",
        "**設定方式**：\n",
        "將這些別名加入 `~/.zshrc` 或 `~/.bashrc`，然後執行 `source ~/.zshrc` 載入。\n",
        "\n",
        "**注意事項**：\n",
        "- 別名只在當前 shell session 有效，需寫入設定檔永久保存\n",
        "- 複雜的邏輯建議改用 shell 函數而非 alias\n",
        "- 避免與系統內建指令重名\n",
        "\n",
        "**進一步學習**：研究 shell 函數、`gh` 的 JSON 輸出搭配 `jq` 實現更複雜的自動化\n",
        "\n",
        "## 實作練習\n",
        "\n",
        "1. 設定你的 `.gitconfig`\n",
        "2. 安裝並試用 lazygit\n",
        "3. 設定 aicommits\n",
        "4. 練習用 `gh` 建立 PR\n",
        "\n",
        "::: {.callout-warning}\n",
        "## 注意\n",
        "永遠不要在主分支上 force push。使用 `--force-with-lease` 代替 `--force`。\n",
        ":::"
      ],
      "id": "bf841b01"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}