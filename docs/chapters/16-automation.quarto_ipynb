{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"自動化與腳本\"\n",
        "---\n",
        "\n",
        "# 自動化與腳本\n",
        "\n",
        "讓重複的事消失。任何做過兩次以上的事，都值得自動化。\n",
        "\n",
        "## 自動化思維\n",
        "\n",
        "問自己：\n",
        "\n",
        "1. 這件事我會再做嗎？\n",
        "2. 做這件事需要多少步驟？\n",
        "3. 自動化需要花多少時間？\n",
        "\n",
        "如果 `重複次數 × 每次時間 > 自動化時間`，就自動化它。\n",
        "\n",
        "## 常見自動化場景\n",
        "\n",
        "### Git 工作流\n",
        "\n",
        "**背景（問題發現）**\n",
        "\n",
        "每天管理 dotfiles 和多個專案時，我們會重複執行相同的 Git 操作：\n",
        "\n",
        "- 切換到 dotfiles 目錄\n",
        "- 加入所有更改\n",
        "- 寫 commit message（最花時間）\n",
        "- 推送到遠端\n",
        "- 回到原目錄\n",
        "\n",
        "這個流程每天可能重複 5-10 次，每次耗時 1-2 分鐘。特別是撰寫有意義的 commit message 需要思考和打字。\n",
        "\n",
        "**方法**\n",
        "\n",
        "建立兩個自動化函數來簡化 Git 工作流：\n",
        "\n",
        "1. `dp()` - 專門用於 dotfiles 的快速提交\n",
        "   - 自動切換到 dotfiles 目錄\n",
        "   - 使用 AI 工具自動生成 commit message\n",
        "   - 推送後返回原目錄\n",
        "\n",
        "2. `zgit()` - 當前專案的快速提交\n",
        "   - 在當前目錄執行\n",
        "   - 使用 conventional commits 格式\n",
        "   - 適合遵循團隊規範的專案\n",
        "\n",
        "**結果（程式碼）**\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 一鍵提交 dotfiles\n",
        "function dp() {\n",
        "    cd $DOTFILES\n",
        "    git add .\n",
        "    aicommits  # AI 生成 commit message\n",
        "    git push\n",
        "    cd -\n",
        "}\n",
        "\n",
        "# 一鍵提交當前專案\n",
        "function zgit() {\n",
        "    git add -A\n",
        "    aicommits --type conventional\n",
        "    git push\n",
        "    cd -\n",
        "}\n",
        "```\n",
        "\n",
        "**討論/延伸**\n",
        "\n",
        "注意事項：\n",
        "- 需要先安裝 `aicommits` 工具（`npm install -g aicommits`）\n",
        "- 確保 `$DOTFILES` 環境變數已設定\n",
        "- `cd -` 會返回到前一個工作目錄\n",
        "\n",
        "變體與改進：\n",
        "- 可加入 `git status` 檢查是否有未提交的更改\n",
        "- 加入錯誤處理：如果 push 失敗要顯示訊息\n",
        "- 可以加入確認步驟，避免誤推送\n",
        "\n",
        "進一步學習：\n",
        "- 了解 [Conventional Commits](https://www.conventionalcommits.org/) 規範\n",
        "- 探索其他 AI commit 工具如 `git-cliff`、`commitizen`\n",
        "- 學習 Git hooks 來自動執行檢查\n",
        "\n",
        "### 專案初始化\n",
        "\n",
        "**背景（問題發現）**\n",
        "\n",
        "每次開始新專案時，我們都需要：\n",
        "\n",
        "1. 從 GitHub clone 模板專案\n",
        "2. 重新命名目錄\n",
        "3. 安裝所有依賴套件\n",
        "4. 清除舊的 Git 歷史\n",
        "5. 重新初始化 Git repository\n",
        "6. 建立第一個 commit\n",
        "\n",
        "這個流程涉及至少 8-10 個指令，容易遺漏步驟或打錯指令。特別是使用同一個模板重複建立專案時（例如使用 Claude Artifact Runner 建立多個實驗專案），每次都要重複相同的操作。\n",
        "\n",
        "**方法**\n",
        "\n",
        "建立一個互動式函數 `cloneclaude()`，自動化整個專案初始化流程：\n",
        "\n",
        "- 使用 GitHub CLI (`gh`) clone 模板 repository\n",
        "- 透過 `read` 指令互動式詢問新專案名稱\n",
        "- 自動執行重新命名、安裝依賴、Git 初始化等步驟\n",
        "- 提供完成訊息確認所有步驟成功\n",
        "\n",
        "**結果（程式碼）**\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "function cloneclaude() {\n",
        "    cd $HOME\n",
        "\n",
        "    # Clone 模板專案\n",
        "    gh repo clone htlin222/claude-artifact-runner\n",
        "\n",
        "    # 詢問新名稱\n",
        "    echo -n \"Enter new folder name: \"\n",
        "    read -r new_folder_name\n",
        "\n",
        "    mv claude-artifact-runner \"$new_folder_name\"\n",
        "    cd \"$new_folder_name\"\n",
        "\n",
        "    # 安裝依賴\n",
        "    npm install\n",
        "\n",
        "    # 重新初始化 Git\n",
        "    rm -rf .git\n",
        "    git init\n",
        "    git add .\n",
        "    git commit -m 'init'\n",
        "\n",
        "    echo \"Project setup complete!\"\n",
        "}\n",
        "```\n",
        "\n",
        "**討論/延伸**\n",
        "\n",
        "注意事項：\n",
        "- 需要安裝並認證 GitHub CLI (`gh auth login`)\n",
        "- 確保網路連線穩定，避免 clone 或 npm install 中斷\n",
        "- `rm -rf .git` 會永久刪除原始 Git 歷史，請確認是否需要保留\n",
        "\n",
        "變體與改進：\n",
        "- 加入錯誤處理：檢查 clone 是否成功\n",
        "- 驗證新專案名稱是否已存在，避免覆蓋\n",
        "- 支援更多模板選擇（傳入參數選擇不同模板）\n",
        "- 自動開啟 VSCode：`code .`\n",
        "- 詢問是否建立 GitHub repository：`gh repo create`\n",
        "\n",
        "範例擴充版本：\n",
        "```bash\n",
        "function cloneclaude() {\n",
        "    local template=\"${1:-htlin222/claude-artifact-runner}\"\n",
        "\n",
        "    gh repo clone \"$template\" || return 1\n",
        "\n",
        "    echo -n \"Enter new folder name: \"\n",
        "    read -r new_folder_name\n",
        "\n",
        "    [[ -d \"$new_folder_name\" ]] && {\n",
        "        echo \"Error: Folder already exists!\"\n",
        "        return 1\n",
        "    }\n",
        "\n",
        "    mv \"${template##*/}\" \"$new_folder_name\"\n",
        "    cd \"$new_folder_name\" || return 1\n",
        "\n",
        "    npm install && rm -rf .git && git init && git add . && \\\n",
        "    git commit -m 'init' && code .\n",
        "}\n",
        "```\n",
        "\n",
        "進一步學習：\n",
        "- 探索 `cookiecutter` 或 `degit` 等專案模板工具\n",
        "- 研究如何建立自己的專案模板\n",
        "- 了解 GitHub Template Repository 功能\n",
        "\n",
        "### 檔案整理\n",
        "\n",
        "**背景（問題發現）**\n",
        "\n",
        "下載資料夾或專案目錄經常累積大量零散檔案：\n",
        "\n",
        "- 螢幕截圖、PDF、圖片、文件等混在一起\n",
        "- 檔名沒有統一格式，難以搜尋\n",
        "- 找特定日期的檔案需要手動檢查每個檔案的修改時間\n",
        "- 手動建立資料夾並移動檔案耗時且容易出錯\n",
        "\n",
        "例如一個下載資料夾可能有 50+ 個檔案，手動整理需要 10-15 分鐘。\n",
        "\n",
        "**方法**\n",
        "\n",
        "建立 `chore()` 函數自動按照檔案修改日期整理檔案：\n",
        "\n",
        "- 掃描當前目錄的所有檔案（不含符號連結）\n",
        "- 讀取每個檔案的修改時間\n",
        "- 使用「日期_檔名」格式建立資料夾\n",
        "- 將檔案移動到對應的資料夾中\n",
        "- 跳過已經有日期前綴的檔案，避免重複處理\n",
        "\n",
        "核心技術：\n",
        "- `date -r \"$file\"` 讀取檔案修改時間\n",
        "- 正則表達式 `^[0-9]{4}-[0-9]{2}-[0-9]{2}_` 判斷是否已有日期前綴\n",
        "- `${file%.*}` 移除副檔名\n",
        "\n",
        "**結果（程式碼）**\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 按日期整理檔案\n",
        "function chore() {\n",
        "    for file in *; do\n",
        "        if [[ -f \"$file\" && ! -L \"$file\" ]]; then\n",
        "            mod_date=$(date -r \"$file\" +\"%Y-%m-%d\")\n",
        "\n",
        "            if [[ ! \"$file\" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_ ]]; then\n",
        "                filename_no_ext=\"${file%.*}\"\n",
        "                new_folder=\"${mod_date}_${filename_no_ext}\"\n",
        "\n",
        "                mkdir -p \"$new_folder\"\n",
        "                mv \"$file\" \"$new_folder/\"\n",
        "\n",
        "                echo \"Moved $file to $new_folder/\"\n",
        "            fi\n",
        "        fi\n",
        "    done\n",
        "}\n",
        "```\n",
        "\n",
        "**討論/延伸**\n",
        "\n",
        "注意事項：\n",
        "- 此函數會修改目錄結構，建議先在測試目錄執行\n",
        "- 只處理檔案，不處理子目錄\n",
        "- 符號連結會被跳過（`! -L \"$file\"`）\n",
        "- 已有日期前綴的檔案不會被重新處理\n",
        "\n",
        "變體與改進：\n",
        "- 按月份分類：改為 `+\"%Y-%m\"` 格式\n",
        "- 按檔案類型分類：加入副檔名判斷\n",
        "- 乾執行模式：加入 `--dry-run` 參數預覽結果\n",
        "- 支援遞迴處理子目錄\n",
        "\n",
        "範例擴充版本（按類型和日期分類）：\n",
        "```bash\n",
        "function chore-type() {\n",
        "    for file in *; do\n",
        "        if [[ -f \"$file\" && ! -L \"$file\" ]]; then\n",
        "            ext=\"${file##*.}\"\n",
        "            mod_date=$(date -r \"$file\" +\"%Y-%m\")\n",
        "\n",
        "            case \"$ext\" in\n",
        "                jpg|png|gif|jpeg) type=\"images\" ;;\n",
        "                pdf) type=\"documents\" ;;\n",
        "                mp4|mov|avi) type=\"videos\" ;;\n",
        "                *) type=\"others\" ;;\n",
        "            esac\n",
        "\n",
        "            new_folder=\"${type}/${mod_date}\"\n",
        "            mkdir -p \"$new_folder\"\n",
        "            mv \"$file\" \"$new_folder/\"\n",
        "            echo \"Moved $file to $new_folder/\"\n",
        "        fi\n",
        "    done\n",
        "}\n",
        "```\n",
        "\n",
        "進一步學習：\n",
        "- 研究 `find` 指令的進階用法（按時間、大小、類型搜尋）\n",
        "- 了解 `rsync` 用於批次檔案操作\n",
        "- 探索 Hazel（macOS）等自動化檔案整理工具\n",
        "\n",
        "### 媒體處理\n",
        "\n",
        "**背景（問題發現）**\n",
        "\n",
        "處理多媒體檔案時經常遇到兩個場景：\n",
        "\n",
        "1. **下載音樂**：想從 YouTube 下載音訊檔案（例如演講、音樂、Podcast），但只需要音訊不需要影片\n",
        "   - 手動使用線上工具：廣告多、品質不穩定、隱私疑慮\n",
        "   - 下載完整影片再轉檔：浪費時間和頻寬\n",
        "\n",
        "2. **合併影片**：需要將多個影片片段合併成一個檔案（例如課程錄影、會議記錄）\n",
        "   - 使用影片編輯軟體：開啟慢、操作複雜、檔案可能重新編碼導致品質損失\n",
        "   - 手動處理 10 個片段可能需要 30 分鐘以上\n",
        "\n",
        "**方法**\n",
        "\n",
        "建立兩個命令列工具函數：\n",
        "\n",
        "1. `yt-mp3()` - YouTube 音訊下載器\n",
        "   - 使用 `yt-dlp` 工具（比 `youtube-dl` 更快更穩定）\n",
        "   - `--extract-audio` 只提取音訊軌道\n",
        "   - `--audio-format mp3` 轉換為通用的 MP3 格式\n",
        "   - `-o \"%(title)s.%(ext)s\"` 使用影片標題作為檔名\n",
        "\n",
        "2. `joinmp4()` - 影片合併工具\n",
        "   - 使用 `ffmpeg` 的 concat demuxer（不重新編碼，速度快）\n",
        "   - 掃描當前目錄所有 `.mp4` 檔案\n",
        "   - 建立 `filelist.txt` 作為合併清單\n",
        "   - `-c copy` 直接複製串流，不重新編碼（保持原始品質）\n",
        "\n",
        "**結果（程式碼）**\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 下載 YouTube 音樂\n",
        "function yt-mp3() {\n",
        "    yt-dlp --extract-audio --audio-format mp3 \\\n",
        "        -o \"%(title)s.%(ext)s\" \"$1\"\n",
        "}\n",
        "\n",
        "# 合併 MP4 檔案\n",
        "function joinmp4() {\n",
        "    for file in *.mp4; do\n",
        "        echo \"file '$file'\" >> filelist.txt\n",
        "    done\n",
        "    ffmpeg -f concat -safe 0 -i filelist.txt -c copy combined.mp4\n",
        "    rm filelist.txt\n",
        "}\n",
        "```\n",
        "\n",
        "**討論/延伸**\n",
        "\n",
        "注意事項：\n",
        "- 需要安裝 `yt-dlp`（`brew install yt-dlp` 或 `pip install yt-dlp`）\n",
        "- 需要安裝 `ffmpeg`（`brew install ffmpeg`）\n",
        "- YouTube 下載需遵守版權法規和 YouTube 使用條款\n",
        "- `joinmp4()` 會合併所有 `.mp4` 檔案，確認目錄中只有需要的檔案\n",
        "- 檔案會按檔名排序，可能需要先重新命名（例如 `01.mp4`, `02.mp4`）\n",
        "\n",
        "變體與改進：\n",
        "\n",
        "**yt-mp3 進階版本**：\n",
        "```bash\n",
        "# 支援播放清單和品質選擇\n",
        "function yt-mp3() {\n",
        "    local quality=\"${2:-5}\"  # 預設品質 5 (128kbps)\n",
        "    yt-dlp --extract-audio --audio-format mp3 \\\n",
        "        --audio-quality \"$quality\" \\\n",
        "        -o \"%(title)s.%(ext)s\" \"$1\"\n",
        "}\n",
        "\n",
        "# 使用：yt-mp3 \"https://youtube.com/watch?v=...\" 0  # 最高品質\n",
        "```\n",
        "\n",
        "**joinmp4 進階版本**：\n",
        "```bash\n",
        "# 支援自訂輸出檔名和檔案順序確認\n",
        "function joinmp4() {\n",
        "    local output=\"${1:-combined.mp4}\"\n",
        "\n",
        "    # 顯示將要合併的檔案順序\n",
        "    echo \"Files to be merged (in order):\"\n",
        "    for file in *.mp4; do\n",
        "        echo \"  - $file\"\n",
        "        echo \"file '$file'\" >> filelist.txt\n",
        "    done\n",
        "\n",
        "    read -p \"Continue? (y/n) \" -n 1 -r\n",
        "    echo\n",
        "    if [[ $REPLY =~ ^[Yy]$ ]]; then\n",
        "        ffmpeg -f concat -safe 0 -i filelist.txt -c copy \"$output\"\n",
        "        echo \"✅ Merged to $output\"\n",
        "    fi\n",
        "    rm filelist.txt\n",
        "}\n",
        "```\n",
        "\n",
        "其他有用的媒體處理函數：\n",
        "```bash\n",
        "# 影片轉 GIF\n",
        "function vid2gif() {\n",
        "    ffmpeg -i \"$1\" -vf \"fps=10,scale=640:-1:flags=lanczos\" \\\n",
        "        -c:v gif \"${1%.*}.gif\"\n",
        "}\n",
        "\n",
        "# 壓縮影片（減小檔案大小）\n",
        "function compress-vid() {\n",
        "    ffmpeg -i \"$1\" -vcodec libx264 -crf 28 \"${1%.*}_compressed.mp4\"\n",
        "}\n",
        "\n",
        "# 提取影片片段\n",
        "function clip-vid() {\n",
        "    local input=\"$1\"\n",
        "    local start=\"$2\"  # 格式：00:01:30\n",
        "    local duration=\"$3\"  # 格式：00:00:45\n",
        "    ffmpeg -i \"$input\" -ss \"$start\" -t \"$duration\" -c copy \\\n",
        "        \"${input%.*}_clip.mp4\"\n",
        "}\n",
        "```\n",
        "\n",
        "進一步學習：\n",
        "- 深入學習 [ffmpeg 官方文件](https://ffmpeg.org/documentation.html)\n",
        "- 探索 `yt-dlp` 的進階功能（字幕下載、播放清單、格式選擇）\n",
        "- 了解影片編碼參數（CRF、bitrate、codec）對品質和檔案大小的影響\n",
        "\n",
        "## 定時任務\n",
        "\n",
        "### macOS launchd\n",
        "\n",
        "**背景（問題發現）**\n",
        "\n",
        "許多重要任務需要定期執行：\n",
        "\n",
        "- 每日備份重要資料（dotfiles、專案、文件）\n",
        "- 定期清理暫存檔案和下載資料夾\n",
        "- 自動更新依賴套件和系統工具\n",
        "- 定期檢查系統健康狀況\n",
        "\n",
        "使用 `cron` 在 macOS 上有限制（系統睡眠時不執行、電源管理問題），而手動執行容易忘記。macOS 的官方解決方案是 `launchd`，它能在系統喚醒後執行錯過的任務，並且有更好的系統整合。\n",
        "\n",
        "**方法**\n",
        "\n",
        "使用 macOS 的 `launchd` 系統建立定時任務：\n",
        "\n",
        "- 在 `~/Library/LaunchAgents/` 建立 `.plist` 設定檔\n",
        "- 定義任務標籤（Label）作為唯一識別\n",
        "- 指定要執行的程式和參數\n",
        "- 設定執行時間（時、分）\n",
        "- 使用 `launchctl` 載入和管理任務\n",
        "\n",
        "關鍵欄位說明：\n",
        "- `Label`: 唯一識別名稱（反向網域命名）\n",
        "- `ProgramArguments`: 要執行的指令（陣列格式）\n",
        "- `StartCalendarInterval`: 定時執行的時間點\n",
        "\n",
        "**結果（程式碼）**\n",
        "\n",
        "建立 `~/Library/LaunchAgents/com.user.backup.plist`：\n",
        "\n",
        "```{xml}\n",
        "#| eval: false\n",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n",
        "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n",
        "  \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n",
        "<plist version=\"1.0\">\n",
        "<dict>\n",
        "    <key>Label</key>\n",
        "    <string>com.user.backup</string>\n",
        "    <key>ProgramArguments</key>\n",
        "    <array>\n",
        "        <string>/bin/bash</string>\n",
        "        <string>/path/to/backup.sh</string>\n",
        "    </array>\n",
        "    <key>StartCalendarInterval</key>\n",
        "    <dict>\n",
        "        <key>Hour</key>\n",
        "        <integer>2</integer>\n",
        "        <key>Minute</key>\n",
        "        <integer>0</integer>\n",
        "    </dict>\n",
        "</dict>\n",
        "</plist>\n",
        "```\n",
        "\n",
        "載入任務：\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "launchctl load ~/Library/LaunchAgents/com.user.backup.plist\n",
        "```\n",
        "\n",
        "**討論/延伸**\n",
        "\n",
        "注意事項：\n",
        "- 路徑必須使用絕對路徑（包含腳本路徑和指令路徑）\n",
        "- 檔案權限要正確：`chmod 644 com.user.backup.plist`\n",
        "- 使用 `launchctl list | grep backup` 檢查任務是否載入成功\n",
        "- 錯誤訊息會記錄在 `~/Library/Logs/` 或系統 Console.app\n",
        "\n",
        "常用 launchctl 指令：\n",
        "```bash\n",
        "# 載入任務\n",
        "launchctl load ~/Library/LaunchAgents/com.user.backup.plist\n",
        "\n",
        "# 卸載任務\n",
        "launchctl unload ~/Library/LaunchAgents/com.user.backup.plist\n",
        "\n",
        "# 立即執行（測試用）\n",
        "launchctl start com.user.backup\n",
        "\n",
        "# 檢視所有任務\n",
        "launchctl list | grep user\n",
        "\n",
        "# 查看任務狀態\n",
        "launchctl list com.user.backup\n",
        "```\n",
        "\n",
        "進階設定範例：\n",
        "\n",
        "**每小時執行**：\n",
        "```xml\n",
        "<key>StartInterval</key>\n",
        "<integer>3600</integer>  <!-- 秒數 -->\n",
        "```\n",
        "\n",
        "**每週一上午 9 點**：\n",
        "```xml\n",
        "<key>StartCalendarInterval</key>\n",
        "<dict>\n",
        "    <key>Weekday</key>\n",
        "    <integer>1</integer>  <!-- 0=週日, 1=週一 -->\n",
        "    <key>Hour</key>\n",
        "    <integer>9</integer>\n",
        "    <key>Minute</key>\n",
        "    <integer>0</integer>\n",
        "</dict>\n",
        "```\n",
        "\n",
        "**監控檔案變化自動執行**：\n",
        "```xml\n",
        "<key>WatchPaths</key>\n",
        "<array>\n",
        "    <string>/Users/username/Documents</string>\n",
        "</array>\n",
        "```\n",
        "\n",
        "**標準輸出/錯誤記錄**：\n",
        "```xml\n",
        "<key>StandardOutPath</key>\n",
        "<string>/tmp/backup.log</string>\n",
        "<key>StandardErrorPath</key>\n",
        "<string>/tmp/backup.error.log</string>\n",
        "```\n",
        "\n",
        "實用範例：定期清理下載資料夾\n",
        "```xml\n",
        "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n",
        "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n",
        "  \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n",
        "<plist version=\"1.0\">\n",
        "<dict>\n",
        "    <key>Label</key>\n",
        "    <string>com.user.cleanup-downloads</string>\n",
        "    <key>ProgramArguments</key>\n",
        "    <array>\n",
        "        <string>/usr/bin/find</string>\n",
        "        <string>/Users/username/Downloads</string>\n",
        "        <string>-type</string>\n",
        "        <string>f</string>\n",
        "        <string>-mtime</string>\n",
        "        <string>+30</string>\n",
        "        <string>-delete</string>\n",
        "    </array>\n",
        "    <key>StartCalendarInterval</key>\n",
        "    <dict>\n",
        "        <key>Hour</key>\n",
        "        <integer>3</integer>\n",
        "        <key>Minute</key>\n",
        "        <integer>0</integer>\n",
        "    </dict>\n",
        "</dict>\n",
        "</plist>\n",
        "```\n",
        "\n",
        "進一步學習：\n",
        "- 閱讀 `man launchd.plist` 了解所有可用選項\n",
        "- 探索 [LaunchControl](https://www.soma-zone.com/LaunchControl/) GUI 工具\n",
        "- 研究系統級任務（`/Library/LaunchDaemons/`）與用戶級任務的差異\n",
        "\n",
        "### Linux cron\n",
        "\n",
        "**背景（問題發現）**\n",
        "\n",
        "在 Linux 系統上，定時任務通常使用 `cron` 來管理。與 macOS 的 `launchd` 類似，我們需要：\n",
        "\n",
        "- 定期備份資料\n",
        "- 自動清理日誌檔案\n",
        "- 定時更新系統套件\n",
        "- 執行健康檢查腳本\n",
        "\n",
        "直接記住 cron 語法並不容易（五個欄位的時間格式），而且錯誤的設定可能導致任務無法執行或執行時間錯誤。\n",
        "\n",
        "**方法**\n",
        "\n",
        "使用 `cron` daemon 的 `crontab` 工具管理定時任務：\n",
        "\n",
        "- 使用 `crontab -e` 編輯當前使用者的 crontab 檔案\n",
        "- 使用五欄位時間格式：`分 時 日 月 週`\n",
        "- 每行一個任務，包含時間和要執行的指令\n",
        "- 系統會在指定時間自動執行腳本\n",
        "\n",
        "Cron 時間格式說明：\n",
        "```\n",
        "*    *    *    *    *\n",
        "│    │    │    │    │\n",
        "│    │    │    │    └─── 週幾 (0-7，0 和 7 都是週日)\n",
        "│    │    │    └──────── 月份 (1-12)\n",
        "│    │    └───────────── 日期 (1-31)\n",
        "│    └────────────────── 小時 (0-23)\n",
        "└─────────────────────── 分鐘 (0-59)\n",
        "```\n",
        "\n",
        "**結果（程式碼）**\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 編輯 crontab\n",
        "crontab -e\n",
        "\n",
        "# 每天凌晨 2 點執行備份\n",
        "0 2 * * * /path/to/backup.sh\n",
        "```\n",
        "\n",
        "**討論/延伸**\n",
        "\n",
        "注意事項：\n",
        "- 使用絕對路徑（cron 的 PATH 環境變數可能不完整）\n",
        "- Cron 執行時的環境變數與登入 shell 不同，可能需要在腳本中設定環境\n",
        "- 預設不會發送輸出，使用 `>` 重導向或設定 `MAILTO` 接收通知\n",
        "- 使用 `crontab -l` 列出現有任務，避免覆蓋\n",
        "\n",
        "常用 crontab 指令：\n",
        "```bash\n",
        "# 編輯 crontab\n",
        "crontab -e\n",
        "\n",
        "# 列出現有任務\n",
        "crontab -l\n",
        "\n",
        "# 刪除所有任務\n",
        "crontab -r\n",
        "\n",
        "# 編輯其他使用者的 crontab (需要 root)\n",
        "sudo crontab -u username -e\n",
        "```\n",
        "\n",
        "常見時間設定範例：\n",
        "\n",
        "```bash\n",
        "# 每分鐘執行\n",
        "* * * * * /path/to/script.sh\n",
        "\n",
        "# 每小時的第 0 分執行\n",
        "0 * * * * /path/to/script.sh\n",
        "\n",
        "# 每天早上 8:30 執行\n",
        "30 8 * * * /path/to/script.sh\n",
        "\n",
        "# 每週一早上 9:00 執行\n",
        "0 9 * * 1 /path/to/script.sh\n",
        "\n",
        "# 每月 1 號凌晨 2:15 執行\n",
        "15 2 1 * * /path/to/script.sh\n",
        "\n",
        "# 每 5 分鐘執行一次\n",
        "*/5 * * * * /path/to/script.sh\n",
        "\n",
        "# 每天 8-17 點的每小時執行\n",
        "0 8-17 * * * /path/to/script.sh\n",
        "\n",
        "# 週一到週五早上 9 點執行\n",
        "0 9 * * 1-5 /path/to/script.sh\n",
        "```\n",
        "\n",
        "實用範例：完整的 crontab 設定\n",
        "```bash\n",
        "# 設定環境變數\n",
        "SHELL=/bin/bash\n",
        "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n",
        "MAILTO=your-email@example.com\n",
        "\n",
        "# 每天凌晨 2 點備份\n",
        "0 2 * * * /home/user/scripts/backup.sh >> /var/log/backup.log 2>&1\n",
        "\n",
        "# 每週日凌晨 3 點清理舊日誌（保留 30 天）\n",
        "0 3 * * 0 find /var/log -name \"*.log\" -mtime +30 -delete\n",
        "\n",
        "# 每小時檢查磁碟空間\n",
        "0 * * * * df -h | grep -E '^/dev/' | awk '$5 > 90 {print \"WARNING: \" $6 \" is \" $5 \" full\"}' | mail -s \"Disk Space Alert\" admin@example.com\n",
        "\n",
        "# 每 15 分鐘檢查服務狀態\n",
        "*/15 * * * * systemctl is-active --quiet nginx || systemctl restart nginx\n",
        "```\n",
        "\n",
        "使用特殊字串（更易讀）：\n",
        "```bash\n",
        "@reboot       /path/to/script.sh      # 系統啟動時執行\n",
        "@yearly       /path/to/script.sh      # 等同於 0 0 1 1 *\n",
        "@annually     /path/to/script.sh      # 同 @yearly\n",
        "@monthly      /path/to/script.sh      # 等同於 0 0 1 * *\n",
        "@weekly       /path/to/script.sh      # 等同於 0 0 * * 0\n",
        "@daily        /path/to/script.sh      # 等同於 0 0 * * *\n",
        "@midnight     /path/to/script.sh      # 同 @daily\n",
        "@hourly       /path/to/script.sh      # 等同於 0 * * * *\n",
        "```\n",
        "\n",
        "除錯技巧：\n",
        "```bash\n",
        "# 測試 cron 腳本（模擬 cron 環境）\n",
        "env -i /bin/sh -c \"export PATH=/usr/bin:/bin; /path/to/script.sh\"\n",
        "\n",
        "# 查看 cron 日誌\n",
        "sudo tail -f /var/log/syslog | grep CRON    # Ubuntu/Debian\n",
        "sudo tail -f /var/log/cron                  # CentOS/RHEL\n",
        "\n",
        "# 加入詳細日誌\n",
        "0 2 * * * /path/to/backup.sh >> /var/log/backup.log 2>&1\n",
        "```\n",
        "\n",
        "進一步學習：\n",
        "- 使用 [crontab.guru](https://crontab.guru/) 線上工具驗證 cron 語法\n",
        "- 探索 `anacron`（適合非 24 小時運行的系統）\n",
        "- 研究 `systemd timers`（現代 Linux 的替代方案）\n",
        "\n",
        "## 通知整合\n",
        "\n",
        "**背景（問題發現）**\n",
        "\n",
        "執行長時間任務時（例如編譯、測試、部署），我們經常遇到這些問題：\n",
        "\n",
        "- 切換到其他視窗工作，忘記檢查任務是否完成\n",
        "- 需要定期回來查看終端機輸出\n",
        "- 任務失敗時沒有立即發現，浪費時間\n",
        "- 想在任務完成時收到提醒，但不想一直盯著螢幕\n",
        "\n",
        "例如 `npm run build` 可能需要 5-10 分鐘，這段時間可以做其他事，但需要知道何時完成。\n",
        "\n",
        "**方法**\n",
        "\n",
        "建立 `notify()` 函數整合 macOS 通知中心：\n",
        "\n",
        "- 使用 `osascript` 執行 AppleScript 指令\n",
        "- `display notification` 顯示系統通知\n",
        "- 接受兩個參數：標題和訊息內容\n",
        "- 與 shell 的 `&&` 運算子結合，在指令成功後發送通知\n",
        "\n",
        "核心技術：\n",
        "- `local` 宣告區域變數\n",
        "- `osascript -e` 執行單行 AppleScript\n",
        "- `&&` 確保前一個指令成功才執行通知\n",
        "\n",
        "**結果（程式碼）**\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "function notify() {\n",
        "    local title=\"$1\"\n",
        "    local message=\"$2\"\n",
        "    osascript -e \"display notification \\\"$message\\\" with title \\\"$title\\\"\"\n",
        "}\n",
        "\n",
        "# 長時間任務完成後通知\n",
        "npm run build && notify \"Build\" \"Complete!\"\n",
        "```\n",
        "\n",
        "**討論/延伸**\n",
        "\n",
        "注意事項：\n",
        "- 僅適用於 macOS（需要 `osascript`）\n",
        "- 需要允許終端機發送通知（系統偏好設定 → 通知）\n",
        "- 使用 `&&` 只在任務成功時通知，失敗則不會觸發\n",
        "- 通知會出現在通知中心，可點擊查看\n",
        "\n",
        "變體與改進：\n",
        "\n",
        "**支援成功/失敗通知**：\n",
        "```bash\n",
        "function notify() {\n",
        "    local title=\"$1\"\n",
        "    local message=\"$2\"\n",
        "    osascript -e \"display notification \\\"$message\\\" with title \\\"$title\\\"\"\n",
        "}\n",
        "\n",
        "# 同時處理成功和失敗\n",
        "npm run build && notify \"Build\" \"✅ Success!\" || notify \"Build\" \"❌ Failed!\"\n",
        "```\n",
        "\n",
        "**加入聲音提示**：\n",
        "```bash\n",
        "function notify() {\n",
        "    local title=\"$1\"\n",
        "    local message=\"$2\"\n",
        "    osascript -e \"display notification \\\"$message\\\" with title \\\"$title\\\" sound name \\\"Glass\\\"\"\n",
        "}\n",
        "\n",
        "# 可用的聲音：Basso, Blow, Bottle, Frog, Funk, Glass, Hero, Morse, Ping, Pop, Purr, Sosumi, Submarine, Tink\n",
        "```\n",
        "\n",
        "**跨平台通知函數**：\n",
        "```bash\n",
        "function notify() {\n",
        "    local title=\"$1\"\n",
        "    local message=\"$2\"\n",
        "\n",
        "    if [[ \"$OSTYPE\" == \"darwin\"* ]]; then\n",
        "        # macOS\n",
        "        osascript -e \"display notification \\\"$message\\\" with title \\\"$title\\\"\"\n",
        "    elif [[ \"$OSTYPE\" == \"linux-gnu\"* ]]; then\n",
        "        # Linux (需要 libnotify)\n",
        "        notify-send \"$title\" \"$message\"\n",
        "    else\n",
        "        # Windows (WSL)\n",
        "        powershell.exe -Command \"New-BurntToastNotification -Text '$title', '$message'\"\n",
        "    fi\n",
        "}\n",
        "```\n",
        "\n",
        "**整合計時功能**：\n",
        "```bash\n",
        "function notify-time() {\n",
        "    local start_time=$(date +%s)\n",
        "    \"$@\"  # 執行傳入的指令\n",
        "    local exit_code=$?\n",
        "    local end_time=$(date +%s)\n",
        "    local duration=$((end_time - start_time))\n",
        "\n",
        "    if [ $exit_code -eq 0 ]; then\n",
        "        notify \"Task Complete\" \"✅ Finished in ${duration}s\"\n",
        "    else\n",
        "        notify \"Task Failed\" \"❌ Failed after ${duration}s (exit code: $exit_code)\"\n",
        "    fi\n",
        "\n",
        "    return $exit_code\n",
        "}\n",
        "\n",
        "# 使用方式\n",
        "notify-time npm run build\n",
        "notify-time pytest tests/\n",
        "```\n",
        "\n",
        "**進階：帶進度的長時間任務**：\n",
        "```bash\n",
        "function long-task-with-progress() {\n",
        "    local total_steps=5\n",
        "\n",
        "    for i in $(seq 1 $total_steps); do\n",
        "        echo \"Step $i of $total_steps...\"\n",
        "        sleep 2  # 模擬工作\n",
        "        osascript -e \"display notification \\\"Step $i/$total_steps completed\\\" with title \\\"Progress\\\"\"\n",
        "    done\n",
        "\n",
        "    notify \"Task\" \"All $total_steps steps completed!\"\n",
        "}\n",
        "```\n",
        "\n",
        "**整合 Slack/Discord 通知**：\n",
        "```bash\n",
        "function notify-slack() {\n",
        "    local message=\"$1\"\n",
        "    local webhook_url=\"YOUR_SLACK_WEBHOOK_URL\"\n",
        "\n",
        "    curl -X POST -H 'Content-type: application/json' \\\n",
        "        --data \"{\\\"text\\\":\\\"$message\\\"}\" \\\n",
        "        \"$webhook_url\"\n",
        "}\n",
        "\n",
        "# 使用\n",
        "npm run build && notify-slack \"✅ Build completed successfully!\"\n",
        "```\n",
        "\n",
        "**實用組合範例**：\n",
        "```bash\n",
        "# 在背景執行並通知\n",
        "function bg-notify() {\n",
        "    \"$@\" &\n",
        "    local pid=$!\n",
        "    wait $pid\n",
        "    local exit_code=$?\n",
        "\n",
        "    if [ $exit_code -eq 0 ]; then\n",
        "        notify \"Background Task\" \"✅ '$*' completed\"\n",
        "    else\n",
        "        notify \"Background Task\" \"❌ '$*' failed (exit: $exit_code)\"\n",
        "    fi\n",
        "}\n",
        "\n",
        "# 使用\n",
        "bg-notify npm run build\n",
        "```\n",
        "\n",
        "進一步學習：\n",
        "- 探索 [terminal-notifier](https://github.com/julienXX/terminal-notifier) 功能更強大的通知工具\n",
        "- 研究 macOS 的 AppleScript 自動化功能\n",
        "- 了解如何整合第三方通知服務（Pushover, Pushbullet）\n",
        "\n",
        "## Makefile 自動化\n",
        "\n",
        "```{makefile}\n",
        "#| eval: false\n",
        ".PHONY: dev build test deploy\n",
        "\n",
        "dev:\n",
        "\tnpm run dev\n",
        "\n",
        "build:\n",
        "\tnpm run build\n",
        "\n",
        "test:\n",
        "\tnpm run test\n",
        "\n",
        "deploy: build\n",
        "\tnetlify deploy --prod --dir=dist\n",
        "```\n",
        "\n",
        "使用：\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "make dev\n",
        "make deploy\n",
        "```\n",
        "\n",
        "## 實作練習\n",
        "\n",
        "1. 為你最常做的工作建立自動化函數\n",
        "2. 設定定時備份腳本\n",
        "3. 建立專案的 Makefile\n",
        "\n",
        "::: {.callout-note}\n",
        "## 原則\n",
        "自動化不是一次性的事。持續觀察你的工作流，找出可以自動化的機會。\n",
        ":::"
      ],
      "id": "05423af4"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}