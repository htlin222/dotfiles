{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"容器化開發\"\n",
        "---\n",
        "\n",
        "# 容器化開發\n",
        "\n",
        "Docker 讓你在隔離的環境中開發，確保「在我的電腦上可以跑」變成「在任何地方都可以跑」。\n",
        "\n",
        "## 安裝\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "在開發過程中，我們經常遇到「在我的電腦上可以跑」的問題。不同的作業系統、不同的套件版本、不同的環境設定都可能導致程式在其他環境無法正常運作。Docker 透過容器化技術解決了這個問題。\n",
        "\n",
        "### 方法\n",
        "\n",
        "Docker 提供兩種主要安裝方式：\n",
        "- **Docker Desktop**：官方完整版，包含圖形介面和完整功能\n",
        "- **OrbStack**：輕量級替代方案，啟動速度快且資源佔用少，特別適合 macOS 用戶\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# macOS\n",
        "brew install --cask docker\n",
        "\n",
        "# 或使用 OrbStack（更輕量）\n",
        "brew install --cask orbstack\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**注意事項：**\n",
        "- Docker Desktop 在 macOS 上可能佔用 2-4GB 記憶體\n",
        "- OrbStack 啟動時間約為 2-3 秒，而 Docker Desktop 需要 20-30 秒\n",
        "- 兩者 CLI 指令完全相容，可以無痛切換\n",
        "\n",
        "**進一步學習：**\n",
        "- 安裝後執行 `docker --version` 確認安裝成功\n",
        "- 執行 `docker run hello-world` 測試 Docker 是否正常運作\n",
        "\n",
        "## 基本命令\n",
        "\n",
        "### 映像檔管理\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "Docker 映像檔（Image）就像是應用程式的「模板」或「快照」。我們需要從 Docker Hub 下載映像檔，才能建立容器來執行應用程式。隨著專案增加，映像檔會佔用大量磁碟空間，需要定期管理。\n",
        "\n",
        "#### 方法\n",
        "\n",
        "映像檔管理的核心概念：\n",
        "- **拉取**：從 Docker Hub 下載映像檔到本機\n",
        "- **列出**：查看已下載的映像檔清單\n",
        "- **刪除**：移除不再需要的映像檔以節省空間\n",
        "\n",
        "標籤（tag）系統用於指定版本，例如 `python:3.12` 表示 Python 3.12 版本。\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 拉取映像檔\n",
        "docker pull python:3.12\n",
        "\n",
        "# 列出映像檔\n",
        "docker images\n",
        "\n",
        "# 刪除映像檔\n",
        "docker rmi python:3.12\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "**實用變體：**\n",
        "```bash\n",
        "# 拉取最新版本\n",
        "docker pull python:latest\n",
        "\n",
        "# 查看映像檔詳細資訊\n",
        "docker inspect python:3.12\n",
        "\n",
        "# 批次刪除無用映像檔\n",
        "docker image prune -a\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- 映像檔可能很大（Python 映像檔約 1GB），首次下載需要時間\n",
        "- 使用 `-slim` 版本可以減少大小，例如 `python:3.12-slim`\n",
        "- 刪除映像檔前要確保沒有容器正在使用它\n",
        "\n",
        "### 容器操作\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "容器（Container）是從映像檔建立的執行實例，就像是從模板建立的實際應用程式。我們需要啟動、監控、停止和清理容器來管理應用程式的生命週期。\n",
        "\n",
        "#### 方法\n",
        "\n",
        "容器操作的核心流程：\n",
        "- **docker run**：從映像檔建立並啟動新容器\n",
        "  - `-it` 參數：互動模式（interactive）+ 配置終端機（TTY）\n",
        "  - `bash` 參數：在容器內執行的命令\n",
        "- **docker ps**：查看容器狀態\n",
        "  - 預設只顯示執行中的容器\n",
        "  - `-a` 參數顯示所有容器（包含已停止的）\n",
        "- **docker stop/rm**：停止和刪除容器\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 執行容器\n",
        "docker run -it python:3.12 bash\n",
        "\n",
        "# 列出執行中的容器\n",
        "docker ps\n",
        "\n",
        "# 列出所有容器\n",
        "docker ps -a\n",
        "\n",
        "# 停止容器\n",
        "docker stop <container_id>\n",
        "\n",
        "# 刪除容器\n",
        "docker rm <container_id>\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "**實用變體：**\n",
        "```bash\n",
        "# 背景執行容器\n",
        "docker run -d python:3.12 python -m http.server\n",
        "\n",
        "# 自動刪除停止的容器\n",
        "docker run --rm -it python:3.12 bash\n",
        "\n",
        "# 停止並刪除容器（一次完成）\n",
        "docker rm -f <container_id>\n",
        "\n",
        "# 批次刪除所有已停止的容器\n",
        "docker container prune\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- 容器 ID 可以只輸入前幾個字元（例如 `abc123` 只需輸入 `abc`）\n",
        "- 停止的容器仍會佔用磁碟空間，記得定期清理\n",
        "- 使用 `--name` 參數可以為容器命名，方便管理\n",
        "\n",
        "### 掛載目錄\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "在開發時，我們希望在本機編輯程式碼，但在容器內執行。如果每次修改都要重建映像檔，開發效率會很低。Volume（掛載卷）讓我們可以在本機和容器之間共享檔案。\n",
        "\n",
        "#### 方法\n",
        "\n",
        "使用 `-v` 參數掛載目錄：\n",
        "- **語法**：`-v 本機路徑:容器路徑`\n",
        "- **$(pwd)**：取得當前目錄的絕對路徑\n",
        "- **-w /app**：設定容器內的工作目錄（working directory）\n",
        "- 本機修改檔案會立即反映到容器內\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 掛載當前目錄\n",
        "docker run -v $(pwd):/app -w /app python:3.12 python script.py\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "**實用變體：**\n",
        "```bash\n",
        "# 只讀掛載（防止容器修改本機檔案）\n",
        "docker run -v $(pwd):/app:ro -w /app python:3.12 python script.py\n",
        "\n",
        "# 掛載特定檔案\n",
        "docker run -v $(pwd)/config.yml:/app/config.yml python:3.12 python main.py\n",
        "\n",
        "# 使用命名卷（Named Volume）持久化資料\n",
        "docker run -v mydata:/data python:3.12 python script.py\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- Windows 用戶使用 `${PWD}` 替代 `$(pwd)`\n",
        "- 路徑必須是絕對路徑，不能使用相對路徑（例如 `./app`）\n",
        "- 掛載大型目錄可能影響容器效能\n",
        "\n",
        "**進一步學習：**\n",
        "- 了解 Volume、Bind Mount、tmpfs 三種掛載方式的差異\n",
        "- 學習使用 `.dockerignore` 檔案排除不需要的檔案\n",
        "\n",
        "## Dockerfile 基礎\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "雖然可以直接使用現成的映像檔，但實際專案需要安裝相依套件、設定環境變數、複製程式碼等客製化設定。Dockerfile 讓我們可以定義自己的映像檔建置流程，確保環境可重現。\n",
        "\n",
        "### 方法\n",
        "\n",
        "Dockerfile 是一個文字檔，包含一系列指令來建置映像檔：\n",
        "- **FROM**：指定基底映像檔（例如 Python 3.12）\n",
        "- **WORKDIR**：設定工作目錄，後續指令都在此目錄執行\n",
        "- **COPY**：複製檔案到映像檔內\n",
        "- **RUN**：在建置時執行命令（例如安裝套件）\n",
        "- **CMD**：容器啟動時預設執行的命令\n",
        "\n",
        "這個範例使用「分層快取」優化：先複製 `requirements.txt` 並安裝套件，再複製整個專案。這樣當程式碼修改時，不會重新安裝套件。\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{dockerfile}\n",
        "#| eval: false\n",
        "# Python 應用範例\n",
        "FROM python:3.12-slim\n",
        "\n",
        "WORKDIR /app\n",
        "\n",
        "COPY requirements.txt .\n",
        "RUN pip install --no-cache-dir -r requirements.txt\n",
        "\n",
        "COPY . .\n",
        "\n",
        "CMD [\"python\", \"main.py\"]\n",
        "```\n",
        "\n",
        "建置和執行：\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 建置映像檔\n",
        "docker build -t myapp .\n",
        "\n",
        "# 執行\n",
        "docker run myapp\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**指令詳解：**\n",
        "- `python:3.12-slim`：使用精簡版 Python，比完整版小 600MB\n",
        "- `--no-cache-dir`：不保存 pip 快取，減少映像檔大小\n",
        "- `-t myapp`：為映像檔命名為 \"myapp\"\n",
        "- `.`：Dockerfile 所在目錄（build context）\n",
        "\n",
        "**最佳實踐：**\n",
        "```dockerfile\n",
        "# 多階段建置（Multi-stage Build）\n",
        "FROM python:3.12 as builder\n",
        "WORKDIR /app\n",
        "COPY requirements.txt .\n",
        "RUN pip install --user --no-cache-dir -r requirements.txt\n",
        "\n",
        "FROM python:3.12-slim\n",
        "WORKDIR /app\n",
        "COPY --from=builder /root/.local /root/.local\n",
        "COPY . .\n",
        "ENV PATH=/root/.local/bin:$PATH\n",
        "CMD [\"python\", \"main.py\"]\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- 每個 RUN、COPY、ADD 指令都會建立新的層（layer）\n",
        "- 將不常改變的指令放在前面，充分利用快取\n",
        "- 使用 `.dockerignore` 排除不需要的檔案（例如 `.git`、`__pycache__`）\n",
        "\n",
        "**進一步學習：**\n",
        "- 研究多階段建置（Multi-stage Build）減少最終映像檔大小\n",
        "- 了解 ENTRYPOINT vs CMD 的差異\n",
        "- 學習使用 ARG 和 ENV 管理環境變數\n",
        "\n",
        "## Docker Compose\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "實際應用通常需要多個容器協作（例如網頁伺服器 + 資料庫 + Redis）。使用 `docker run` 指令逐一啟動容器很麻煩，而且難以管理容器間的網路連接和依賴關係。Docker Compose 讓我們用一個設定檔管理多容器應用。\n",
        "\n",
        "### 方法\n",
        "\n",
        "`docker-compose.yml` 是一個 YAML 格式的設定檔，定義所有服務：\n",
        "- **services**：定義各個容器\n",
        "  - **build**：從 Dockerfile 建置映像檔\n",
        "  - **image**：使用現成的映像檔\n",
        "  - **ports**：埠號對應（本機埠號:容器埠號）\n",
        "  - **volumes**：掛載目錄或命名卷\n",
        "  - **depends_on**：定義啟動順序\n",
        "  - **environment**：環境變數設定\n",
        "- **volumes**：定義命名卷，用於持久化資料\n",
        "\n",
        "這個範例設定了一個 Web 應用和 PostgreSQL 資料庫，資料庫的資料會持久化到 `pgdata` 卷中。\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{yaml}\n",
        "#| eval: false\n",
        "version: '3.8'\n",
        "services:\n",
        "  web:\n",
        "    build: .\n",
        "    ports:\n",
        "      - \"8000:8000\"\n",
        "    volumes:\n",
        "      - .:/app\n",
        "    depends_on:\n",
        "      - db\n",
        "\n",
        "  db:\n",
        "    image: postgres:15\n",
        "    environment:\n",
        "      POSTGRES_PASSWORD: secret\n",
        "    volumes:\n",
        "      - pgdata:/var/lib/postgresql/data\n",
        "\n",
        "volumes:\n",
        "  pgdata:\n",
        "```\n",
        "\n",
        "操作命令：\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 啟動所有服務\n",
        "docker compose up -d\n",
        "\n",
        "# 查看 log\n",
        "docker compose logs -f\n",
        "\n",
        "# 停止所有服務\n",
        "docker compose down\n",
        "\n",
        "# 重建\n",
        "docker compose up --build\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**指令詳解：**\n",
        "- `-d`：背景執行（detached mode）\n",
        "- `-f`：持續顯示 log（follow mode）\n",
        "- `--build`：強制重建映像檔\n",
        "\n",
        "**實用變體：**\n",
        "```bash\n",
        "# 只啟動特定服務\n",
        "docker compose up -d web\n",
        "\n",
        "# 查看特定服務的 log\n",
        "docker compose logs -f web\n",
        "\n",
        "# 重啟服務\n",
        "docker compose restart web\n",
        "\n",
        "# 停止並刪除所有資源（包含卷）\n",
        "docker compose down -v\n",
        "\n",
        "# 查看服務狀態\n",
        "docker compose ps\n",
        "```\n",
        "\n",
        "**最佳實踐：**\n",
        "```yaml\n",
        "# 使用環境變數檔案\n",
        "services:\n",
        "  web:\n",
        "    env_file:\n",
        "      - .env\n",
        "  db:\n",
        "    environment:\n",
        "      POSTGRES_PASSWORD: ${DB_PASSWORD}\n",
        "\n",
        "# 健康檢查\n",
        "  web:\n",
        "    healthcheck:\n",
        "      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8000/health\"]\n",
        "      interval: 30s\n",
        "      timeout: 10s\n",
        "      retries: 3\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- `depends_on` 只確保啟動順序，不保證服務已就緒\n",
        "- 資料庫密碼應使用環境變數或 Docker Secrets，不要寫死在設定檔\n",
        "- 使用 `docker compose down -v` 會刪除卷內的資料，需謹慎使用\n",
        "\n",
        "**進一步學習：**\n",
        "- 研究 Docker Compose 的網路模式（bridge、host、overlay）\n",
        "- 學習使用 Docker Secrets 管理敏感資訊\n",
        "- 了解 healthcheck 和 restart 策略的最佳實踐\n",
        "\n",
        "## 開發工作流\n",
        "\n",
        "### 開發環境容器\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "開發環境需要即時重載（hot reload）、除錯工具、原始碼掛載等功能，這些與生產環境的需求不同。我們需要分開開發和生產的 Docker Compose 設定，避免在生產環境包含開發工具。\n",
        "\n",
        "#### 方法\n",
        "\n",
        "使用獨立的 `docker-compose.dev.yml` 設定開發環境：\n",
        "- **Dockerfile.dev**：開發環境專用的 Dockerfile（包含開發工具）\n",
        "- **volumes**：掛載本機程式碼，實現即時重載\n",
        "  - `.:/app`：掛載專案目錄\n",
        "  - `/app/node_modules`：排除 node_modules（使用容器內的版本）\n",
        "- **command**：覆寫預設命令，執行開發伺服器\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{yaml}\n",
        "#| eval: false\n",
        "# docker-compose.dev.yml\n",
        "services:\n",
        "  dev:\n",
        "    build:\n",
        "      context: .\n",
        "      dockerfile: Dockerfile.dev\n",
        "    volumes:\n",
        "      - .:/app\n",
        "      - /app/node_modules  # 排除 node_modules\n",
        "    ports:\n",
        "      - \"3000:3000\"\n",
        "    command: npm run dev\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "**使用方式：**\n",
        "```bash\n",
        "# 使用開發設定檔\n",
        "docker compose -f docker-compose.dev.yml up\n",
        "\n",
        "# 同時使用多個設定檔（合併設定）\n",
        "docker compose -f docker-compose.yml -f docker-compose.dev.yml up\n",
        "```\n",
        "\n",
        "**Dockerfile.dev 範例：**\n",
        "```dockerfile\n",
        "FROM node:20\n",
        "\n",
        "WORKDIR /app\n",
        "\n",
        "# 安裝開發工具\n",
        "RUN npm install -g nodemon\n",
        "\n",
        "COPY package*.json ./\n",
        "RUN npm install\n",
        "\n",
        "COPY . .\n",
        "\n",
        "CMD [\"npm\", \"run\", \"dev\"]\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- 排除 `node_modules` 避免本機和容器版本衝突\n",
        "- 開發環境不需要優化映像檔大小，可以包含除錯工具\n",
        "- 使用 `nodemon` 或類似工具實現自動重載\n",
        "\n",
        "**最佳實踐：**\n",
        "- 建立 `.env.dev` 和 `.env.prod` 分別管理環境變數\n",
        "- 使用 `docker-compose.override.yml`（預設會自動載入）存放本機專屬設定\n",
        "- 在 `.gitignore` 中排除 `docker-compose.override.yml`\n",
        "\n",
        "### 進入執行中的容器\n",
        "\n",
        "#### 背景（問題發現）\n",
        "\n",
        "在除錯或檢查容器狀態時，我們需要進入容器內部執行命令，例如查看檔案、檢查環境變數、執行資料庫查詢等。直接停止容器再重新執行會中斷服務。\n",
        "\n",
        "#### 方法\n",
        "\n",
        "使用 `docker exec` 在執行中的容器內執行命令：\n",
        "- **exec**：在容器內執行新的命令（不影響原有程序）\n",
        "- **-it**：互動模式 + TTY，讓我們可以像 SSH 一樣操作容器\n",
        "- **container_name**：容器名稱或 ID\n",
        "- **bash**：要執行的命令（通常是 shell）\n",
        "\n",
        "#### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "docker exec -it <container_name> bash\n",
        "```\n",
        "\n",
        "#### 討論/延伸\n",
        "\n",
        "**實用變體：**\n",
        "```bash\n",
        "# 如果容器沒有 bash，使用 sh\n",
        "docker exec -it <container_name> sh\n",
        "\n",
        "# 執行單一命令（不進入互動模式）\n",
        "docker exec <container_name> ls -la /app\n",
        "\n",
        "# 以 root 身份執行\n",
        "docker exec -u root -it <container_name> bash\n",
        "\n",
        "# 進入最近建立的容器\n",
        "docker exec -it $(docker ps -lq) bash\n",
        "```\n",
        "\n",
        "**常見使用情境：**\n",
        "```bash\n",
        "# 檢查資料庫連線\n",
        "docker exec -it myapp_db psql -U postgres\n",
        "\n",
        "# 查看 log 檔案\n",
        "docker exec myapp_web cat /var/log/app.log\n",
        "\n",
        "# 執行資料庫遷移\n",
        "docker exec myapp_web python manage.py migrate\n",
        "\n",
        "# 檢查環境變數\n",
        "docker exec myapp_web env\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- `docker exec` 只能在執行中的容器使用\n",
        "- 容器內修改的檔案（非掛載目錄）在容器停止後會遺失\n",
        "- 某些精簡映像檔（如 Alpine）可能沒有 `bash`，只有 `sh`\n",
        "\n",
        "**進一步學習：**\n",
        "- 了解 `docker attach` vs `docker exec` 的差異\n",
        "- 學習使用 `docker cp` 在容器和本機之間複製檔案\n",
        "- 研究如何使用 `nsenter` 進入容器的命名空間\n",
        "\n",
        "## 實用別名\n",
        "\n",
        "### 背景（問題發現）\n",
        "\n",
        "Docker 指令往往很長，需要記憶多個參數和選項。重複的操作（如清理資源、查看 log、進入容器）會消耗大量時間。Shell 別名可以將常用的複雜指令簡化為一個字。\n",
        "\n",
        "### 方法\n",
        "\n",
        "使用 `alias` 定義快捷指令：\n",
        "- **docker system prune -af**：清理所有無用資源\n",
        "  - `-a`：刪除所有未使用的映像檔（不只是懸掛的）\n",
        "  - `-f`：強制執行，不詢問確認\n",
        "- **$(docker ps -lq)**：取得最近建立的容器 ID\n",
        "  - `-l`：最近的容器（last）\n",
        "  - `-q`：只輸出 ID（quiet）\n",
        "\n",
        "### 結果（程式碼）\n",
        "\n",
        "```{bash}\n",
        "#| eval: false\n",
        "# 清理無用的容器和映像檔\n",
        "alias docker-clean='docker system prune -af'\n",
        "\n",
        "# 進入最近的容器\n",
        "alias docker-last='docker exec -it $(docker ps -lq) bash'\n",
        "\n",
        "# 查看容器 log\n",
        "alias docker-logs='docker logs -f $(docker ps -lq)'\n",
        "```\n",
        "\n",
        "### 討論/延伸\n",
        "\n",
        "**更多實用別名：**\n",
        "```bash\n",
        "# 停止所有容器\n",
        "alias docker-stop-all='docker stop $(docker ps -q)'\n",
        "\n",
        "# 刪除所有容器\n",
        "alias docker-rm-all='docker rm $(docker ps -aq)'\n",
        "\n",
        "# 查看容器資源使用量\n",
        "alias docker-stats='docker stats --no-stream'\n",
        "\n",
        "# Docker Compose 快捷指令\n",
        "alias dcu='docker compose up -d'\n",
        "alias dcd='docker compose down'\n",
        "alias dcl='docker compose logs -f'\n",
        "alias dcr='docker compose restart'\n",
        "\n",
        "# 進入 web 服務容器\n",
        "alias docker-web='docker compose exec web bash'\n",
        "\n",
        "# 查看映像檔大小\n",
        "alias docker-size='docker images --format \"table {{.Repository}}\\t{{.Tag}}\\t{{.Size}}\"'\n",
        "```\n",
        "\n",
        "**安裝方式：**\n",
        "將這些別名加入 shell 設定檔（`.bashrc` 或 `.zshrc`）：\n",
        "```bash\n",
        "# 編輯設定檔\n",
        "echo 'alias docker-clean=\"docker system prune -af\"' >> ~/.zshrc\n",
        "\n",
        "# 重新載入設定\n",
        "source ~/.zshrc\n",
        "```\n",
        "\n",
        "**注意事項：**\n",
        "- `docker-clean` 會刪除所有未使用的資源，包含停止的容器、未使用的網路、懸掛的映像檔\n",
        "- 執行清理前請確認沒有重要的停止容器需要保留\n",
        "- 別名只在當前 shell 有效，需加入設定檔才能永久保存\n",
        "\n",
        "**進一步學習：**\n",
        "- 研究 shell 函數（function）實現更複雜的功能\n",
        "- 了解如何使用 `fzf` 套件建立互動式容器選擇器\n",
        "- 學習 `docker system df` 查看磁碟使用量\n",
        "\n",
        "## 實作練習\n",
        "\n",
        "1. 拉取一個 Python 映像檔並執行 bash\n",
        "2. 建立一個簡單的 Dockerfile\n",
        "3. 用 Docker Compose 設定開發環境\n",
        "\n",
        "::: {.callout-warning}\n",
        "## 注意\n",
        "Docker Desktop 在 macOS 上可能佔用大量資源。考慮使用 OrbStack 作為替代，它更輕量且啟動更快。\n",
        ":::"
      ],
      "id": "8c854d69"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}